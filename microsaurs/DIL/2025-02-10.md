# Chap 11. CPU 스케줄링

## CPU 스케줄링 개요

모든 프로세스는 CPU 필요, 먼저 사용하고 하려고 함  
→ CPU는 프로세스들에게 공정하고 합리적으로 CPU 자원을 할당해야함

**CPU 스케줄링**  
운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

### 1. 프로세스 우선순위

프로세스마다 `우선순위`가 다름

- 우선순위가 높은 프로세스 → 입출력 작업이 많은 프로세스
- 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에 차이 존재
  > - **입출력 집중 프로세스** : 입출력 작업이 더 많은 프로세스
      → 실행 상태보다는 입출력을 위한 대기 상태가 더 김
  > - **CPU 집중 프로세스** : CPU 작업이 더 많은 프로세스
      → 대기 상태보다는 실행 상태가 더 김
  > **[CPU 버스트와 입출력 버스트]**
  >
  > - CPU 버스트 : CPU를 이용하는 작업
  > - 입출력 버스트 : 입출력장치를 기다리는 작업  
  >   → 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행  
  >   **입출력 집중 프로세스는 입출력 버스트가 많은 프로세스, CPU 집중 프로세스는 CPU 버스트가 많은 프로세스**

프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 `우선순위` 부여  
→ 운영체제는 각 프로세스의 PCB에 우선순위를 명시, 우선순위를 기준으로 먼저 처리할 프로세스 결정

### 2. 스케줄링 큐

운영체제가 프로세스들에 '줄을 서서 기다릴 것'을 요구 → **이 줄을 `스케줄링 큐`로 구현하고 관리**  
💡운영체제가 관리하는 대부분의 자원은 **큐로 관리**

> - **준비 큐** : CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미
> - **대기 큐** : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미

### 3. 선점형과 비선점형 스케줄링

- **선점형 스케줄링**  
   프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식  
   → 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
- **비선점형 스케줄링**  
   하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식  
   → 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식  
  💡현재 대부분의 운영체제는 선점형 스케줄링 방식 차용

> **[선점형/비선점형 장단점]**
>
> - **선점형**  
>   더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점  
>   문맥 교환 과정에서 어버헤드 발생 가능성
> - **비선점형**  
>   문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하느 ㄴ오버헤드는 선점형 스케줄링보다 적음  
>   하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 대기, 모든 프로세스가 골고루 자원을 사용할 수 없음

## CPU 스케줄링 알고리즘

### 1. 스케줄링 알고리즘의 종류

\* 운영체제마다 다르고 매우 다양, 여러 가지 아이디어 중 하나로 공부하기

**[선입 선처리 스케줄링]**  
FCFS 스케줄링 (First Come First Served Scheduling)  
단순히 준비 큐에 **삽입된 순서대로** 프로세스들을 처리하는 비선점형 스케줄링 방식  
/\* 때대로 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용 발생 = `호위 효과`

**[최단 작업 우선 스케줄링]**  
준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행  
기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수도 있음

**[라운드 로빈 스케줄링]**  
선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식

> **타임 슬라이스** : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미

→ 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링  
💡라운드 로빈 스케줄링에서는 타임 슬라이스의 크기가 매우 중요 !
→ 타임 슬라이스가 지나치게 크면 호위 효과 발생, 지나치게 작으면 문맥 교환 발생 비용이 커져 효율이 떨어짐

**[최소 잔여 시간 우선 스케줄링]**  
최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식  
최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스 선택

**[우선순위 스케줄링]**  
프로세스들에 우선순위르 ㄹ부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘  
\* 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 알고리즘은 넓은 의미에서 우선순위 스케줄링의 일종

> - **기아 현상**  
>   준비 큐에 먼저 삽입되었음에도 불구하고 우선순위가 낮은 프로세스는 실행이 계속해서 연기되는 현상
> - **에이징**  
>   오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식 (기아현상 해결을 위한 방법)

**[다단계 큐 스케줄링]**  
우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식  
→ 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해짐  
큐별로 타임 슬라이스 지정, 다른 스케줄링 알고리즘 사용 가능해서 더 유연하게 관리 가능

**[다단계 피드백 큐 스케줄링]**  
다단계 큐 스케줄링의 기아 현상 발생을 보완한 스케줄링 방식  
→ 프로세스들이 큐 사이를 이동할 수 있음

> 새로 준비 상태가 된 프로세스는 우선 순위가 가장 높은 큐에 삽입, 일정 시간 실행  
> 해당 큐에서 실행이 끝나지 않으면 다음 우선순위 큐로 이동, 실행  
> 또 다시 해당 큐에서 실행이 끝나지 않으면 또 다음 우선순위 큐로 이동  
> → CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐

- 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘
- 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져있음
