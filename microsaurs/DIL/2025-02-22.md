# Chap 14. 가상 메모리

## 연속 메모리 할당

연속 메모리 할당 : 프로세스에 연속적인 메모리 공간을 할당하는 방식

### 1. 스와핑

메모리에 적재된 프로세스들 중에 현재 실행되지 않은 프로세스를 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식

- 스왑 영역 : 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인 : 스왑 영여겡 있던 프로세스가 다시 메모리로 옮겨지는 것  
  \* 스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리주소와는 다른 주소에 적재될 수 있음

💡 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행 가능

### 2. 메모리 할당

- 최초 적합  
   운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식  
   프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식
  → **검색을 최소화, 결과적으로 빠른 할당**

- 최적 적합  
  운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식

- 최악 적합  
  운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식

### 3. 외부 단편화

프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하면서 메모리 사이 사이에 빈 공간이 발생  
프로세스 바깥에 생기는 이러한 빈공간들은 그 공간보다 큰 프로세스를 적재하기 어려움 → **메모리 낭비**  
➡️ 외부 단편화 현상

외부 단편화 현상이 일어나기 때문에 연속 메모리 할당은 사실 효율적인 메모리 사용 방식이 아님 !

**[외부 단편화 해결 방법]**

- 압축 compaction (=메모리 조각 모음)  
  여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
  - **단점**  
    작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지  
    메모리에 있는 내용을 옮기는 작업은 많은 오버헤드 야기  
    어던 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법 결정이 어려움

➡️ 이외에도 가상 메모리, 페이징 기법 등이 있음

## 페이징을 통한 가상 메모리 관리

메모리 연속 할당 방식의 문제점

- 외부 단편화
- 물리 메모리보다 큰 프로세스를 실행 X

**[가상 메모리]**  
실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술  
**[가상 메모리 관리 기법]**

- **페이징** ✔️ (대부분의 운영체제가 사용)
- 세그멘테이션

### 1. 페이징이란

프로세스의 논리 주소 공간을 **페이지**page라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임**frame이라는 페이지와 동일한 크기의 일정 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

페이징 사용 시스템에서도 스와핑 가능  
→ 프로세스 전체가 스왑 아웃, 스왑 인 되는 것이 아니라 **페이지 단위로 스왑 아웃, 스왑 인**  
\* 페이징 시스템에서 스왑 아웃은 **페이지 아웃**, 스왑 인은 **페이지 인** 이라고도 함  
➡️ 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요 X  
 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있음  
 → 물리 메모리보다 더 큰 프로세스 실행 가능

### 2. 페이지 테이블

페이징 기법의 문제점  
→ 프로세스가 메모리에 불연속적으로 배치, CPU 입장에서 순차적 실행 불가  
 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알 수 없음  
 프로세스가 메모리에 불연속적으로 배체되면 CPU 입장에서 다음에 실행할 명령어 위치를 찾기가 어려워짐

이를 해결하기 위해,  
페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 **페이지 테이블 이용**

> 물리 주소 : 실제 메모리 내의 주소  
> 논리 주소 : CPU가 바라보는 주소

페이지 테이블 : 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표  
→ 현재 어떤 페이지가 어떤 프레임에 할당되었는지 알려주는 역할

\* 프로세스마다 각자의 프로세스 테이블을 가지고 있음

💡 내부 단편화  
페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자름  
그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리지 않음  
프로세스 크기가 페이지의 배수가 아니라는 의미  
프로세스 크기보다 더 만들어지는 페이지의 크기가 낭비됨 → **내부 단편화**  
\* 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생

하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것이라고 생각할 수 있지만, 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비 됨  
➡️ 내부 단편화를 적당히 방지하면서 너무 크기 않은 페이지 테이블이 만ㄷ르어지도록 페이지 크기 조정하는 것이 중요 !

**[페이지 테이블 베이스 레지스터 PTBR]**  
각 프로세스의 페이지 테이블이 적재된 주소를 가리킴  
ex. 프로세스 A가 실행될 때 PTBR은 프로세스 A의 페이지 테이블을 가리키고, CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있음

**[TLB]**  
페이지 테이블을 메모리에 두면 메모리 접근을 2번 해야 하는 문제 발생  
(메모리 > 페이지 테이블 조회, 프레임 접근시)  
→ TLB라는 페이지 테이블의 캐시 메모리를 둠

- 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용 저장
- 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장

**[TLB 히트]**  
CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우  
페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요 X(메모리 접근 1회)

**[TLB 미스]**  
페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근

### 3.페이징에서의 주소 변환

하나의 페이지, 프레임은 여러 주소를 포괄  
특정 주소에 접근하기 위해서는 2가지 정보가 필요

- 어떤 페이지 혹은 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지  
  → 페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지 번호 + 변위**로 이루어져 있음

> 페이지 번호 : 접근하고자 하는 페이지 번호  
> 변위 : 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보  
> 논리 주소 <페이지 번호, 변위> → 페이지 테이블 → 물리 주소 <프레임 번호, 변위> 로 변환  
> \* 논리 주소의 변위와 물리 주소의 변위는 같음  
> ⭐️ 예제 보면서 이해하기 (검색)

#### 4. 페이지 테이블 엔트리

페이지 테이블의 각각의 행  
페이지 번호, 프레임 번호 말고도 '유효 비트', '보호 비트', '참조 비트', '수정 비트' 포함

**[유효 비트]**  
현재 해당 페이지에 접근 가능한지 여부 알림  
\* 프레임 번호 다음으로 중요한 정보  
일반적으로 프로세스를 이루는 모든 페이지가 메모리에 있지 않고, 일부 페이지는 보조 기억장치(스왑 영역)에 존재  
→ **현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려주는 비트**

> 현재 페이지가 메모리에 적재되어 있으면 유효 비트 1(true)  
> 현재 페이지가 메모리에 적재되어 있지 않으면 유효 비트 0 (false)

- 페이지 폴트 page fault  
  CPU가 유효 비트가 0인 페이지로 접근하려고 하면 페이지 폴트 예외가 발생

[CPU가 페이지 폴트를 처리하는 과정]

1. CPU는 기존의 작업 내역을 백업
2. 페이지 폴트 처리 루틴 실행
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
4. 페이지 폴트를 처리했다면 CPU는 해당 페이지로 접근  
   \* 하드웨어 인터럽트 처리 과정과 유사

**[보호 비트]**  
페이지 보호 기능을 위해 존재하는 비트  
보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 간으한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있음

> 보호 비트 0 : 읽기만 가능  
> 보호 비트 1 : 읽기 + 쓰기 가능

- 읽기(Read)
- 쓰기(Write)
- 실행(eXecute)

**[참조 비트]**  
CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄

> 참조 비트 1 : 적재 이후 CPU가 읽거나 쓴 페이지  
> 참조 비트 0 : 적재 이후 CPU가 한 번도 읽거나 쓴 적이 없는 페이지

**[수정 비트]**  
= 더티 비트  
해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부 알림

> 수정 비트 1 : 변경된 적이 있는 페이지  
> 수정 비트 0 : 변경된 적이 없는 페이지(한 번도 접근한 적 없거나 읽기만 했던 페이지)

수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지 판단하기 위해 존재
