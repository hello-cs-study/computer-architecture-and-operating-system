# Chap 10. 프로세스와 스레드

## 프로세스 개요

💡 **프로세스 : 실행 중인 프로그램**

### 1. 프로세스 직접 확인하기

> - **포그라운드 프로세스** : 사용자가 보는 앞에서 실행되는 프로세스
> - **백그라운드 프로세스** : 사용자가 보지 못하는 뒷편에서 실행되는 프로세스

    사용자와 상호작용 하지 않고 정해진 일만 수행하는 백그라운드 프로세스
    유닉스 → 데몬(daemon) | 윈도우 → 서비스(service)

### 2. 프로세스 제어 블록

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원 배분  
**→ 프로세스 제어 블록(PCB)를 이용**

- 프로세스와 관련된 정보를 저장하는 자료 구조
- 해당 프로세스를 식별하기 위해 꼭 필요한 정보들 저장, 커널 영역에 생성
- 프로세스 생성 시에 만들어지고 실행이 끝나면 페기
  > 새로운 프로세스가 생성되었다 = 운영체제가 PCB를 생성했다  
  > 프로세스가 종료되었다 = 운영체제가 해당 PCB를 폐기했다

**[프로세스 ID]**  
특정 프로세스를 식별하기 위해 부여하는 고유한 번호

**[레지스터 값]**  
프로세스 실행 이전의 레지스터 중간값들을 모두 복원 → 이전까지 진행하던 작업들을 이어서 실행  
PCB 안에는 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들 존재

**[프로세스 상태]**  
현재 프로세스가 어떤 상태인지 PCB에 기록

**[CPU 스케줄링 정보]**  
프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록

**[메모리 관리 정보]**  
프로세스마다 메모리에 저장된 위치가 다름  
PCB에는 프로세스가 어느 주소에 저장되어 있는지에 대한 정보 필요  
PCB에는 베이스 레지스터, 한계 레지스터 값과 같은 정보들이 담김  
프로세스의 주소를 알기위한 페이지 테이블 정보도 담김

**[사용한 파일과 입출력장치 목록]**  
프로세스가 실행 과정에서 특정 입출력장치나 파일을 사용하면 PCB에 해당 내용이 명시

### 3. 문맥 교환

**문맥** : 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보  
하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현  
→ 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것 `문맥 교환`

### 4. 프로세스의 메모리 영역

**[코드 영역]**  
= 텍스트 영역  
기계어로 이루어진 명령어가 저장  
데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 **쓰기가 금지**  
**→ 읽기 전용 read-only 공간**

**[데이터 영역]**  
프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간  
ex. 전역 변수

**[힙 영역]**  
프로그래머가 직접 할당할 수 있는 저장 공간  
할당이 진행됐으면 언젠간 반드시 반환 (메모리 공간 사용 여부 변경)  
\* 메모리 누수 : 메모리 공간을 반환하지 않는 경우 메모리 낭비 초래

**[스택 영역]**  
데이터를 일시적으로 저장하는 공간  
ex. 매개 변수, 지역 변수

> - **정적 할당 영역**  
>   코드영역 : 프로그램을 구성하는 명령어들이 바뀔 일 X, 크기 일정  
>   데이터 영역 : 프로그램이 실행되는 동안에만 유지될 데이터, 크기 변함 X
> - **동적 할당 영역**  
>   힙 영역, 스택 영역 : 프로세스 실행 과정에서 그 크기가 변할 수 있는 영역

## 프로세스 상태와 계층 구조

### 1. 프로세스 상태

**[생성 상태]**  
프로세스를 생성 중인 상태 → `new`

**[준비 상태]**  
당장 실행이 가능하지만, 차례를 기다리며 대기하고 있는 상태 → `ready`

**[실행 상태]**  
CPU를 할당받아 실행 중인 상태 → `running`  
프로세스가 할당된 시간을 모두 사용한다면 다시 준비 상태가 되고, 실행 도중 입출력장치를 사용하여 입출력 장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태로 전환

**[대기 상태]**  
입출력장치의 작업을 기다리는 상태 → `blocked`  
입출력 작업이 완료되면 다시 준비 상태로 전환

**[종료 상태]**  
프로세스가 종료된 상태 → `terminated`  
운영체제는 PCB와 프로세스가 사용한 메모리를 정리

### 2. 프로세스 계층 구조

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있음

> **부모 프로세스** : 새 프로세스를 생성한 프로세스  
> **자식 프로세스** : 부모 프로세스에 의해 생성된 프로세스  
> \* 부모 > 자식 > 자식 > 자식 ... 으로 계속 계층적으로 생성될 수 있음

### 3. 프로세스 생성 기법

→ 부모 프로세스를 통해 생성된 자식 프로세스들은 `복제와 옷 갈아입기`를 통해 실행

- 부모 프로세스가 `fork`를 통해 자신의 복사본을 자식 프로세스로 생성
- 자식 프로세스(복사본)은 `exec`를 통해 자신의 메모리 공간을 다른 프로그램으로 교체  
  \* fork와 exec는 시스테 ㅁ호출
  > fork : 자기 자신 프로세스의 복사본을 만드는 시스템 호출  
  > exec : 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출
