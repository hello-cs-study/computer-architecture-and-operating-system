# Chap 5. CPU 성능 향상 기법

### 빠른 CPU를 위한 설계 기법

1. **클럭**  
   ➡️ 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복  
   ➡️ 일반적으로 클럭 속도가 높은 CPU는 성능이 좋음  
   ➡️ 클럭 속도가 CPU 속도 단위로 간주되기도 함

- **클럭 속도**  
  ➡️ 1초에 클럭이 몇 번 반복되는지 나타냄 (헤르츠Hz 단위)

\* 클럭 속도를 높인다고 무조건 CPU가 빨라지는 것 X  
\* 클럭 속도만으로 CPU의 성능을 올리는 것은 한계가 존재

2. **코어와 멀티코어**

- CPU의 성능을 높이는 다른 방법  
  ➡️ CPU의 코어와 스레드 수를 늘리기

**[코어를 늘리는 방법]**  
➡️ 과거 CPU의 정의였던 **'명령어를 실행하는 부품'** => 현대에는 **'코어'** 라는 용어로 사용  
\* 오늘날의 CPU는 '명령어를 실행하는 부품을 여러 개 포함하는 부품'으로 명칭 범위 확장  
ex. 8 core = 명령어를 실행하는 부품을 8개 가지고 있다는 의미

- 멀티코어 CPU(멀티코어 프로세서) : 코어를 여러 개 포함하고 있는 CPU

\* CPU의 연산 속도는 코어 수에 비례하여 증가 X  
➡️ 코어마다 처리할 연산이 적절히 분배되지 않는 경우 코어 수에 비례하여 연산 속도가 증가하지 않음  
ex. 학교 팀 과제에 모두가 같은 성과를 내지 않음

3. **스레드와 멀티스레드**

- 스레드 : 실행 흐름의 단위(사전적 정의)
  > 하드웨어적 스레드  
  > 소프트웨어적 스레드

#### 하드웨어적 스레드

➡️ 하나의 코어가 동시에 처리하는 명령어 단위  
\* CPU에서 사용하는 스레드 용어는 보통 CPU 입장에서 정의된 하드웨어적 스레드를 의미

> 멀티스레드 CPU(멀티스레드 CPU) : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU  
> ex. 8코어 16스레드 : 명령어를 실행하는 부품을 8개 포함, 한 번에 16개의 명령어를 처리할 수 있는 CPU 의미  
> 하이퍼스레딩 : 인텔의 멀티스레드 기술

#### 소프트웨어적 스레드

➡️ 하나의 프로그램에서 독립적으로 실행되는 단위  
\* 프로그래밍 언어나 운영체제를 학습할 때 접하는 스레드는 보통 소프트웨어적으로 정의된 스레드를 의미

#### 멀티스레드 프로세서

➡️ 하나의 코어로 여러 명령어를 동시에 처리하는 CPU

> 멀티스레드 프로세서의 가장 큰 핵심은 `레지스터`  
> 하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 **꼭 필요한 레지스터를 여러 개 가지고 있으면 됨**  
> 논리 프로세서  
> ➡️ 2코어 4스레드 CPU는 한 번에 4개의 명령어를 처리할 수 있는데,  
> 프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 4개 있는 것처럼 보임

**[정리]**

> 코어 : 명령어를 실행할 수 있는 `하드웨어 부품`  
> 스레드 : `명령어를 실행하는 단위`  
> 멀티코어 프로세서 : 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU  
> 멀티스레드 프로세서 : 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

<br>

### 명령어 병렬 처리 기법

➡️ CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만들기  
➡️ 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법!

1. **명령어 파이프라인**  
   ➡️ 명령어 파이프라인을 이해하려면 하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어 보기  
   : 클럭 단위로 나눠보기
   > 명령어 인출(Instruction Fetch)  
   > 명령어 해석(Instruction Decode)  
   > 명령어 실행(Execute Instruction)  
   > 결과 저장(Write Back)  
   > \* `중요` : 같은 단계가 겹치지 않으면, CPU는 **'각 단계를 동시에 실행 가능'**

- **명령어 파이프라이닝** : 마치 공장 생산 라인과 같이 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 파이프라이닝은 높은 성능을 가져오지만, 특정 상황에서는 성능 향상에 실패  
  ➡️ **파이프라인 위험** : 데이터 위험 / 제어 위험 / 구조적 위험

- **데이터 위험**  
  ➡️ `데이터 의존성`에 의해 발생  
  ex. 이전 단계를 실행해야만 다음 단계를 실행할 수 있는 경우

- **제어 위험**  
  ➡️ 주로 분기 등으로 인한 `프로그램 카운터의 갑작스러운 변화`에 의해 발생  
  ex. 프로그램 실행 흐름이 바뀌어 프로그램 카운터 값에 변화가 생기면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들이 쓸모없게 됨  
  \* **분기 예측** : 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술

- **구조적 위험 (=자원 위험)**  
  ➡️ 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생  
  <br>

2. **슈퍼스칼라**  
   ➡️ 여러 개의 명령어 파이프라인을 포함한 구조  
   (공장 생산 라인을 여러 개 두는 것과 같음!)
   > 슈퍼스칼라 CPU(슈퍼스칼라 프로세서) : 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU  
   > 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 함

\* 이론적으로 파이프라인 개수이 비례하여 프로그램 처리 속도가 빨라짐  
but, 파이프라인 위험 등의 예상치 못한 문제로 인해 실제로 반드시 파이프라인 개수에 비례하여 빨라지는 것은 아님 !

> 슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험 방지를 위해 고도로 설계되어야 함 ⭐️

<br>

3. **비순차적 명령어 처리**  
   ➡️ 명령어들을 순차적으로 실행하지 않는 기법(OoOE)  
   ⭐️ 명령어의 `합법적인 새치기`
   > 앞의 코드를 이루는 명령어들 중 서로 데이터 의존성이 전혀 없는, 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들을 먼저 수행시키는 방법  
   > 이러한 방식으로 파이프라인이 멈추는 것을 방지하는 기법!  
   > 비순차적 명령어 처리가 가능한 CPU = 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지 판단 가능해야 함.

<br>

### CISC와 RISC

1. **명령어 집합**
   > 명령어 집합(=ISA) : CPU가 이해할 수 있는 명령어들의 모음  
   > CPU마다 ISA가 다를 수 있음

\* ISA가 같은 CPU끼리는 서로의 명령어 이해 가능, ISA가 다른 경우 명령어 이해 불가능  
➡️ `ISA는 일종의 CPU의 언어`

- CPU가 이해하는 명령어 다르면, 제어장치의 해석 방식, 레지스터의 종류와 개수, 메모리 관리 방법 등 다른 요소들도 달라짐

**⭐️ ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속**

2. **CISC**  
   ➡️ Complex Instruction Set Computer  
   : 복잡한 명령어 집합을 활용하는 컴퓨터를 의미
   > 다양하고 강력한 기능의 명령어 집합 활용  
   > 명령어의 형태와 크기가 다양한 `가변 길이 명령어` 활용

\* 프로그램을 실행하는 명령어 수가 적다는 말은 '컴파일된 프로그램의 크기가 작다'는 것을 의미

➡️ CISC는 메모리를 최대한 아끼며 개발해야 했던 시절에 인기 ⬆️  
➡️ '적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다'

> CISC의 치명적 단점
> 활용하는 명령어가 복잡하고 다양한 기능을 제공
> ➡️ **명령어의 크기와 실행되기까지의 시간이 일정하지 않음**  
> ➡️ 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 **여러 클럭 주기 필요**  
> 명령어 파이프 라인을 구현하는데 장애 요소  
> ➡️ 규격화되지 않은 명령어가 파이프라이닝을 어렵게 만듦  
> \* 명령어 파이프라인이 제대로 동작하지 않는다는 것은 현대 CPU에 치명적인 약점

✔️ CISC이 주는 교훈

- 빠른 처리를 위해 명령어 파이프라인을 십분 활용해야 함.
- 원활한 파이프라이닝을 위해 **'명령어 길이와 수행 시간이 짧고 규격화'** 되어 있어야함
- 어차피 자주 쓰이는 명령어만 줄곧 사용
- 복잡한 기능 추가보다는 '**자주 쓰이는 기본 명령어를 작고 빠르게 만드는 것이 중요'**

<br>

3. **RISC**  
   ➡️ Reduced Instruction Set Computer
   > CISC에 비해 명령어 수가 적음  
   > CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어 지향  
   > **고정 길이 명령어**  
   > RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한  
   > **➡️ 메모리 접근을 단순화하고 최소화를 추구**  
   > \* `load-store 구조`  
   > 레지스터 적극 활용  
   > ➡️ 레지스터 이용 연산 많고, 범용 레지스터 개수도 더 많음
