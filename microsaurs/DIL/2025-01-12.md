# Chap2. 데이터

### 0과 1로 숫자를 표현하는 방법

1. **정보단위**

   > 비트 : 0과 1을 표현할 수 있는 가장 작은 정보 단위 (2^n개 표현 가능)  
   > 바이트 : 8개의 비트를 묶은 단위  
   > 그 이상의 단위들 : 이전 단위 1,000개 묶어 표현  
   > \* 워드(word) : CPU가 한 번에 처리할 수 있는 데이터 크기 의미

2. **이진법**  
   ➡️ 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 모든 수를 표현하는 방법  
   표기 방법 : 끝에 아래첨자 (2) 혹은 앞에 0b

   #### 이진수의 음수 표현

   > `2의 보수`  
   > 모든 0과 1을 뒤집고, 거기에 1을 더한 값  
   > 이진수의 음수를 표현하는 완벽한 방식은 아님  
   > <br> > **십진수와 이진수 음수 구분법** `플래그`  
   > ➡️ 어떤 값을 다룰 때 부가 정보가 필요한 경우 **플래그 사용**

3. **십육진법**  
    ➡️ 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법  
    표기 방법 : 끝에 아래첨자 (16) 혹은 앞에 0x  
    <br>
   > **십육진법 사용 이유**  
   > ➡️ 이진수와 십육진수의 변환이 용이  
   > \* 코드에 십육진수를 직접 쓰는 경우가 있다는 사실 알아두기

<br>

### 0과 1로 문자를 표현하는 방법

#### 문자 집합과 인코딩

    > 문자 집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
    > 인코딩 : 문자를 0과 1로 변환하는 과정
    > 디코딩 : 0과 1로 이루어진 문자 코드를 문자로 변환하는 과정

`아스키코드`  
➡️ 아스키 : 영어 알파벳과 아라비아 숫자, 일부 특수문자 포함한 문자 집합  
 아스키 문자에 대응된 고유한 수 = 아스키 코드

> **한글 인코딩의 특수성**  
> 완성형 인코딩 : 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여  
> 조합형 인코딩 : 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성
>
> `EUC-KR`  
> ➡️ KS X 1001, KS X 1003이라는 문자 집합을 기반으로 하는 대표적인 완성형 인코딩 방식  
> 모든 한글을 표현하는데에는 한계가 꽤 큼

`유니코드와 UTF-8`

> 유니코드 : 여러 나라의 문자를 광버위하게 표현할 수 있는 통일된 문자 집합  
> UTF-8, UTF-16, UTF-32는 유니코드 문자의 인코딩 방식

<br>

# Chap3. 명령어

### 소스 코드와 명령어

1.  고급 언어와 저급 언어

    > 고급 언어 : 사람을 위한 언어  
    > 저급 언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어

        * 기계어 : 0과 1의 명령어 비트로 이루어진 언어
        * 어셈블리어 : 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

    ### 저급 언어를 알아야하는 이유

    컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 프로그램이 어떤 절차로 작동하는지를 가장 근본적인 단계에서 부터 하나하나 추적하고 관찰할 수 있음  
    \* 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보 보안 분야 등의 개발자는 어셈블리어를 많이 이용

2.  컴파일 언어와 인터프리터 언어
    > **고급 언어가 저급 언어로 변환되는 과정**
    >
    > - 컴파일 방식
    > - 인터프리트 방식  
    >   \* 현대의 많은 프로그래밍 언어 중에는 컴파일 언어와 인터프리터 언어 간의 경계가 모호한 경우가 많음

<br>

`컴파일 언어`
➡️ 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어  
ex. C언어

- 컴파일 : 컴파일 언어로 작성된 소스 코드 전체가 저급 언어로 변환되는 과정
- 컴파일러 : 컴파일을 수행해 주는 도구
- 목적 코드 : 컴파일러를 통해 저급 언어로 변환된 코드

`인터프리터 언어`  
➡️ 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어  
ex. 파이썬

- 인터프리터 : 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구  
  <br>

### 명령어의 구조

1. 연산 코드와 오퍼랜드
   > 명령어 : 연산 코드와 오퍼랜드로 구성  
   > 연산 코드 : 명령어가 수행할 연산(연산자)  
   > 오퍼랜드 : 연산에 사용할 데이터, 연산에 사용한 데이터가 저장된 위치(피연산자)

`오퍼랜드`  
➡️ 오퍼랜드 필드 : 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소  
 \* 주로 값이 직접 오기보다는 주소가 오는 경우가 많음 -> 주소 필드라고도 부름

`연산 코드`  
➡️ 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어

<br>

2. 주소 지정 방식  
   💡 오퍼랜드 필드에 주소를 담는 이유 = 명령어 길이  
   \* 유효 주소 : 연산 코드에 사용할 데이터가 저장된 위치, 연산의 대상이 되는 데이터가 저장된 위치

➡️ 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법  
 주소 지정 방식 = 유효 주소 찾는 방법

`즉시 주소 지정 방식`  
➡️ 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식

- 가장 간단한 형태의 주소 지정 방식
- 연산에 사용한 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 빠름  
  <br>

`직접 주소 지정 방식`  
➡️ 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식

- 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한생길 수 있음  
  <br>

`간접 주소 지정 방식`  
➡️ 유효 주소의 주소를 오퍼랜드 필드에 명시

- 두 번의 메모리 접근이 필요하기 때문에 느린 편
  <br>

`레지스터 주소 지정 방식`  
➡️ 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식

- 일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 내부에 있는 레지스터에 접근하는 것이 더 빠름
- 직접 주소 지정 방식보다 빠르게 데이터에 접근
- 표현할 수 있는 레지스터 크기에 제한 생길 수 있음  
  <br>

`레지스터 간접 주소 지정 방식`
➡️ 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법

- 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 장점
- 간접 주소 지정 방식보다 빠름
  <br>  
  <br>

### 💡 스택과 큐

`스택`  
➡️ 한쪽 끝이 막혀 있는 통과 같은 저장 공간

- 후입선출 LIFO(리포)
- 데이터 저장 명령어 PUSH, 데이터 꺼내는 명령어 POP
  <br>

`큐`
➡️ 양쪽이 뚫려 있는 통과 같은 저장 공간

- 한쪽으로는 데이터를 저장, 다른 한쪽으로는 먼저 저장한 순서대로 데이터를 ㅃ내ㅐㅁ
- 선입선출 FIFO(피포)
