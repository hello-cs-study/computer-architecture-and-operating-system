# Chap8. 입출력 장치

### 다양한 입출력 방법

1. **프로그램 입출력**  
   프로그램 속 명령어로 입출력장치를 제어하는 방법  
   → CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어짐

   **[CPU가 장치 컨트롤러의 레지스터를 아는 방법(입출력장치의 주소)]**

   - **메모리 맵 입출력**  
      메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법  
      CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 됨!  
      → 메모리에 접근하는 명령어와 입출력장치에 접근하는 **명령어가 다를 필요 X**

   - **고립형 입출력**  
      메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법  
      CPU는 입출력장치에 접근하기 위해 메모리에 접근하는 명령어와는 **다른 입출력 명령어 사용**  
     <br>

2. **인터럽트 기반 입출력**

   > - CPU가 입축력장치에 처리할 내용을 명령하면 입출력장치가 명령어를 수행하는 동안 CPU는 다른 일을 할 수 있음
   > - 입출력장치가 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 멈추고 해당 인터럽트를 처리하는 프로그램인 인터럽트 서비스 루틴을 실행한 뒤 다시 하던 일로 되돌아옴

    <br>
    하드웨어 인터럽트는 입출력장치가 아닌 장치 컨트롤러에 의해 발생

   1. CPU는 장치 컨트롤러에 입출력 작업 명령
   2. 장치 컨트롤러가 입출력 장치를 제어 및 입출력 수행
   3. CPU 다른 일 수행 가능
   4. 장치 컨트롤러가 입출력 작업 끝낸 뒤 CPU에게 인터럽트 요청 신호 전송
   5. CPU는 하던 일 백업 후 인터럽트 서비스 루틴 실행

   ➡️ CPU는 인터럽트 간에 우선순위를 고려하여 **우선순위가 높은 인터럽트 순**으로 여러 인터럽트를 처리

   플래그 레지스터 속 인터럽트 비트가 활성화되어 잇는 경우 or 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트가 발생한 경우 **→ CPU는 우선순위가 높은 인터럽트부터 처리**

   > NMI(Non-Maskable Interrupt) : 무시할 수 없는 인터럽트

   **[프로그래머블 인터럽트 컨트롤러(PIC)]**  
    우선순위를 반영하여 다중 인터럽트를 처리하는 방법 중 많이 사용하는 방법  
    여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별,  
    CPU에 지금 처리해야 할 하드웨어 인터럽트가 무엇인지 알려주는 장치

   > **PIC의 다중 인터럽트 처리 과정**
   >
   > - PIC가 장치 컨트롤러에서 **인터럽트 요청 신호 수신**
   > - PIC는 인터럽트 **우선순위 판단** 후, CPU에 처리해야 할 **인터럽트 요청 신호 전송**
   > - CPU는 PIC에 **인터럽트 확인 신호 전송**
   > - PIC는 데이터 버스를 통해 CPU에 **인터럽트 벡터 전송**
   > - CPU는 인터럽트 벡터를 통해 인터럽트 **요청의 주체**를 알게 되고, 해당 장치의 **인터럽트 서비스 루틴 실행**  
   >   \* 일반적으로 더 많고 복잡한 장치들의 인터럽트를 관리하기 위해 PIC를 **두 개 이상 계층적으로 구성**

<br>

3. **DMA 입출력**  
   입출력장치와 메모리 사이에 전송되는 모든 데이터는 CPU를 반드시 거친다는 공통점  
   → CPU는 입출력장치를 위한 연산 등 때문에 시간을 뺏기게 됨

   ### DMA(Direct Memory Access)

   ➡️ 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식  
    DMA를 입출력하기 위해서는 시스템 버스에 연결된 `DMA 컨트롤러`라는 하드웨어 필요

   > **DMA 입출력 과정**
   >
   > - CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등과 같은 정보로 **입출력 작업 명령**
   > - DMA 컨트롤러는 CPU 대신 **장치 컨트롤러와 상호작용하며 입출력 작업을 수행**(필요한 경우 메모리에 직접 접근)
   > - 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업 종료 알림

   > **메모리 내의 정보를 하드디스크에 백업하는 작업 (DMA 입출력)**
   >
   > - CPU는 DMA 컨트롤러에 하드 디스크 주소, 수행할 연산, 백업할 내용이 저장된 메모리의 주소 등의 정보와 함께 **입출력 작업 명령**
   > - DMA 컨트롤러는 CPU를 거치지 않고 **메모리와 직접 상호작용**하며 백업할 정보를 읽어옴
   > - 하드 디스크의 장치 컨트롤러에 전송
   > - 백업이 끝나면 DMA 컨트롤러는 CPU에게 인터럽트 걸어 작업 종료 알림

   ➡️ DMA 컨트롤러는 시스템 버스로 메모리에 직접 접근 가능 but 시스템 버스는 **동시 사용 불가능**  
    ✔️ CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 사용 불가  
    \* DMA 컨트롤러가 시스템 버스를 사용하는 것을 `사이클 스틸링`이라고 함

   #### 입출력 버스

   CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스를 공유하는 구성에서는 DMA를 위해 한 번 메모리에 접근할 때마다 **시스템 버스를 두 번 사용하게 되는 부작용 발생**  
    ➡️ DMA 컨트롤러와 장치 컨트롤러들을 `입출력 버스`라는 별도의 버스에 연결하여 해결

   > **입출력 버스**
   >
   > - PCI(Peripheral Component Interconnect) 버스
   > - PCI Expres (PCle) 버스
   > - PCle 슬롯 : 여러 입출력장치들을 PCle 버스와 연결해 주는 통로
