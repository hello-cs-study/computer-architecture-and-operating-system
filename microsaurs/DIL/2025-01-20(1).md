# Chap4. CPU의 작동 원리

### ALU와 제어장치

> CPU = 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치  
> ALU = 계산을 담당  
> 제어장치 = 명령어를 읽어 들이고 해석  
> 레지스터 = 작은 임시 저장 장치

1. **ALU**

- ALU가 **받아들이는 정보**  
  ➡️ 레지스터를 통해 **피연산자**  
  ➡️ 제어장치를 통해 **제어 신호**  
  : 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산 수행

- ALU가 **내보내는 정보**  
  ➡️ 연산을 수행한 결과 (ex. 특정 숫자, 문자, 메모리 주소 등)  
  \* 결과값은 메모리에 바로 저장되지 않고, 일시적으로 레지스터에 저장  
  ➡️ **플래그** (연산에 대한 추가적인 정보) → **플래그 레지스터**에 저장  
  ex. 계산 결과가 음수인 경우, 레지스터의 크기보다 결과값이 큰 경우(오버플로우) 등..

**[ALU 결과값을 레지스터에 저장하는 이유]**  
 → CPU가 메모리에 접근하려면 속도가 오래 걸림 → 프로그램 속도 늦어짐

**[플래그 종류]**

> 부호플래그 : 연산 결과의 부호  
> 제로 플래그 : 연산 결과가 0인지 여부  
> 캐리 플래그 : 연산 결과 올림수나 빌림수가 발생했는지 여부  
> 오버플로우 플래그 : 오버플로우 발생 여부  
> 인터럽트 플래그 : 인터럽트 가능 여부  
> 슈퍼바이저 플래그 : 커널 모드로 실행 중인지 사용자 모드로 실행중인지 나타냄  
> → 플래그는 거의 0과 1로 표현됨

\* 이외에도 ALU 내부에는 계산을 위한 회로가 다양하게 존재  
ex. 가산기(덧셈), 보수기(뺄셈), 시프터(시프트 연산), 오버플로우 검출기 등

<br>

2. **제어장치**  
   : 제어 신호를 내보내고, 명령어를 해석하는 부품

\* CPU의 구성 요소 중 가장 정교하게 설계된 부품!

- 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

#### 제어장치가 받아들이는 정보

➡️ 클럭, 현재 수행할 명령어, 플래그, 제어 신호

1. 클럭 신호
   > 클럭 : 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게 하는 시간 단위  
   > \* 컴퓨터의 모든 부품이 한 클럭마다 작동한다 **X**  
   > \* 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동할 뿐 한 박자 마다 작동하는 것은 아님!
2. 해석해야 할 명령어
   > **명령어 레지스터**에 저장  
   > 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용 전달
3. 플래그 레지스터 속 플래그 값
4. 시스템 버스 중 제어 버스로 전달된 제어 신호
   > 입출력 장치를 비롯한 CPU 외부 장치도 발생시킬 수 있음 (보조기억장치 포함)

#### 제어장치가 내보내는 정보

- 제어장치가 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶으면 메모리로 제어 신호를 내보냄
- 제어장치가 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때는 입출력 장치로 제어 신호 내보냄

**[제어장치가 CPU 내부에 전달하는 제어 신호]**

> **ALU에 전달**하는 제어 신호 : 수행할 연산 지시  
> **레지스터에 전달**하는 제어 신호 : 레지스터 간의 데이터 이동, 저장된 명령어 해석

<br>

### 레지스터

**[반드시 알아야 할 레지스터]**

> **프로그램 카운터** : 메모리에서 읽어 들일 명령어의 주소 저장 (=명령어 포인터)  
> **명령어 레지스터** : 해석할 명령어를 저장하는 레지스터  
> **메모리 주소 레지스터** : 메모리 주소 저장 레지스터  
> **메모리 버퍼 레지스터** : 메모리와 주고받을 값 저장 레지스터 (=메모리 데이터 레지스터)

\* 프로그램 카운터가 꾸준히 증가하기 때문에 프로그램이 차례대로 계속 실행될 수 있음  
\* 순차적인 실행 흐름이 끊기는 경우  
→ 주소를 강제적으로 이동시키는 명령어를 사용한 경우  
ex. JUMP, CONDITIONAL JUMP, CALL, RET ...  
→ 인터럽트가 발생

> **플래그 레지스터** : 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장  
> **범용 레지스터** : 다양하고 일반적인 상황에서 자유롭게 사용하는 레지스터 → 데이터와 주소를 모두 저장할 수 있음

<br>

**[특정 레지스터를 이용한 주소 지정 방식]**

> **스택 주소 지정 방식**  
> → 스택과 스택 포인터를 이용한 주소 지정 방식  
> \* 스택은 한 쪽이 막혀있는 저장 공간으로 LIFO 방식  
> **스택 포인터** : 스택의 꼭대기를 가리키는 레지스터  
> → 스택 포인터는 스택의 어디까지 데이터가 채워져 있는지에 대한 표시!  
> **스택 영역** : 메모리 안에 스택처럼 사용할 영역이 정해져 있음  
> \* 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역

<br>

> **변위 주소 지정 방식**  
> → 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식  
> 명령어 : 연산 코드 필드, (어떤)레지스터 값, 오퍼랜드  
> 어떤 레지스터가 무엇인지에 따라 종류가 나뉨  
> → 상대 주소 지정 방식 / 베이스 레지스터 주소 지정 방식

- 상대 주소 지정 방식  
  → 오퍼랜드 + 프로그램 카운터 => 유효주소  
  \* 프로그램 카운터에는 읽어들일 명령어의 주소가 저장  
  \* 상대 주소 지정 방식은 **분기하여 특정 주소의 코드를 실행할 때 사용**

- **베이스 레지스터 주소 지정 방식**  
  → 오퍼랜드 + 베이스 레지스터 값 => 유효주소  
  \* 베이스 레지스터 = 기준 주소, 오퍼랜드 = 기준 주소로부터 떨어진 거리  
  \* 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 **얼마나 떨어진 주소에 접근할 것인지 연산**하여 유효 주소를 얻어내는 방식  
  <br>

### 명령어 사이클과 인터럽트

- 명령어 사이클 : 하나의 명령어를 처리하는 정형화된 흐름
- 인터럽트 : 명령어 사이클 흐름이 끊어지는 상황

1. **명령어 사이클**  
   → 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행

   > 인출 사이클 : 메모리에 있는 명령어를 CPU로 가져오는 단계  
   > 실행 사이클 : CPU로 가져온 명령어를 실행하는 단계  
   > \* 프로그램을 이루는 수많은 명령어는 인출과 실행 사이클을 반복하며 실행  
   > 간접 사이클 : 명령어 실행을 위해 메모리에 한 번 더 접근해야하는 경우 실행하는 단계

2. **인터럽트**  
   → CPU가 수행 중인 작업을 방해하는 신호
   > 동기 인터럽트  
   > → CPU에 의해 발생하는 인터럽트 = **예외 Exception**  
   > 비동기 인터럽트  
   > → 주로 입출력장치에 의해 발생하는 인터럽트 = **하드웨어 인터럽트(인터럽트)**

- **하드웨어 인터럽트**  
  → 알림과 같은 인터럽트  
   \* 하드웨어 인터럽트를 사용하면 CPU는 주기적으로 입출력장치의 상태를 확인할 필요가 없기 때문에 효율성 ⬆️ (다른 업무 처리 가능)

**[하드웨어 인터럽트 처리 순서]**

1. 입출력장치가 CPU에 **인터럽트 요청 신호** 전송
2. CPU -> 실행 사이클 종류 후, 명령어 인출 후 인터럽트 여부 확인
3. CPU가 인터럽트 요청 확인 후, **인터럽트 플래그**를 통해 현재 인터럽트 수용 가능 여부 확인
4. 인터럽트 수용 가능하면 CPU는 지금까지 작업 백업
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
6. 인터럽트 서비스 루틴 실행 후, 4번에서 백업해둔 작업 복구 후 실행 재개  
   \* 인터럽트가 발생한 경우 기존 실행하던 데이터는 스택에 백업 !

> 인터럽트 요청 신호 : 인터럽트 가능 여부 확인하는 요청 신호  
> 인터럽트 플래그 : 하드웨어 인터럽트를 받아들일지 무시할지 결정하는 플래그  
> \* CPU가 중요한 작업을 처리 or 방해 받으면 안되는 상태 => 인터럽트 플래그 불가능으로 설정됨  
> \* 정전이나 하드웨어 고장으로 인한 인터럽트는 가장 우선순위 인터럽트 -> CPU가 무시 불가  
> 인터럽트 서비스 루틴 : 인터럽트를 처리하기 위한 프로그램 (=인터럽트 핸들러)  
> 인터럽트 벡터 : 인터럽트 서비스 루틴을 식별하기 위한 정보  
> \* CPU가 작업을 수행하는 도중 인터럽트가 발생한 경우, 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 시작 주소를 알아내고, 이 시작 주소부터 실행
