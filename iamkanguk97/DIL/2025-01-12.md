## 03-2) 명령어의 구조

## 연산코드와 오퍼랜드

- `명령어`: 연산코드와 오퍼랜드로 구성되어 있음 (ex. 더해라 - 100과 120을)
- `연산코드`: 명령어가 수행할 연산 (연산자)
- `오퍼랜드`: 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치 (피연산자)

```
push rbp
mov  rbp, rsp
mov  DWORD PTR [rbp-4], 1
```

### 오퍼랜드

> - 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치
> - 그래서 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올수 있다.
> - **그렇지만 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.**

- 명령어 = 연산코드 + 오퍼랜드
- 그런데 오퍼랜드는 없을 수도, 최대 3개까지 올 수 있다.

### 연산코드

> 크게 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어 타입이 있다.

#### 데이터 전송

- MOVE: 데이터를 옮겨라
- STORE: 메모리에 저장하라
- LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
- PUSH: 스택에 데이터를 저장해라
- POP: 스택의 최상단 데이터를 가져와라

#### 산술/논리 연산

- ADD / SUBSTRACT / MULTIPLY / DIVIDE
- INCREMENT / DECREMENT: 오퍼랜드에 1을 더해라 또는 빼라
- AND / OR / NOT
- COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교해라

#### 제어 흐름 변경

- JUMP: 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT: 프로그램의 실행을 멈춰라
- CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라

#### 입출력 제어

- READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
- START IO: 입출력 장치를 시작하라
- TEST IO: 입출력 장치의 상태를 확인하라

### 주소 지정 방식

> - 명령어의 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많다.
> - 그래서 오퍼랜드 필드를 주소 필드라고 부른다.
> - 그런데 왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담을까? 그냥 연산코드, 연산코드에 사용될 데이터 형식으로 명령어를 구성하면 안될까?

이는 `명령어 길이` 때문이다. 하나의 명령어가 n비트로 구성되어 있고, 그중 연산코드 필드가 m비트라고 한다면<br/>
오퍼랜드 필드의 길이는 n-m 비트이다. 이 때 오퍼랜드 필드에 1개부터 3개까지 갈수록 크기는 작아진다.

예를 들어, 명령어의 크기가 16비트이다. 그리고 연산코드 필드가 4비트라고 한다면 총 12비트가 남는다.<br/>
그런데 3-주소 명령어라고 한다면 12 / 3 해서 각 오퍼랜드가 4비트 길이이다.

**만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.**

현재 CPU는 다양한 `주소 지정 방식`을 사용한다.

#### 즉시 주소 지정 방식 (Immediate addressing mode)

> **연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식**

- 가장 간단한 형태의 주소 지정 방식
- **표현할 수 있는 데이터의 크기가 작아진다는 단점이 있지만 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 주소 지정 방식들보다 빠르다.**

#### 직접 주소 지정 방식 (Direct addressing mode)

> **오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식**

- 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다는 더 커졌음.
- 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다.
- 다시 말해서 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져서 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

#### 간접 주소 지정 방식 (Indirect addressing mode)

> **유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식**

- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어짐.
- 다만 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식들보다 일반적으로 느린 방식이다.

#### 레지스터 주소 지정 방식 (Register addressing mode)

> **직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법**

- **일반적으로 CPU 외부에 있는 메모리에 접근하는 것 보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다.**
- 그래서 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다.
- 하지만, 레지스터 주소 지정 방식은 직접 주소 지정 방식과 비슷한 문제를 공유한다.
- **표현할 수 있는 레지스터 크기에 제한이 생길 수 있다는 점이다.**

#### 레지스터 간접 주소 지정 방식 (Register indirect addressing mode)

> **연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법**

간접 주소 지정방식보다 빠르다.

#### 정리

- 연산에 사용할 데이터를 찾는 방법을 `주소 지정 방식` 이라고 한다.
- 연산에 사용할 데이터가 저장된 위치를 `유효 주소` 라고 한다.
- 그리고 대표적인 주소 지정 방식으로는 5가지 방식이 있다.
  - 즉시 주소 지정 방식: 연산에 사용할 데이터
  - 직접 주소 지정 방식: 유효 주소 (메모리 주소)
  - 간접 주소 지정 방식: 유효 주소의 주소
  - 레지스터 주소 지정 방식: 유효 주소 (레지스터 이름)
  - 레지스터 간접 주소 지정 방식: 유효 주소를 저장한 레지스터

### 정리

- `명령어`: **연산코드와 오퍼랜드로 구성된다.**
- `연산 코드`: **명령어가 수행할 연산을 의미한다.**
- `오퍼랜드`: **연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치**
- `주소지정방식`: **연산에 사용할 데이터 위치를 찾는 방법**
