> 읽은 페이지: 402~416

## 페이징을 통한 가상 메모리 관리

-   프로세스를 메모리에 연속적으로 할당하는 방식은 `외부 단편화`와 `물리 메모리보다 큰 프로세스를 실행할 수 없다`는 단점이 있다.
-   `가상 메모리(Virtual Memory)`는 실행하고자 하는 프로그램을 일부만 메모리에 적재해서 실제 물리 메모리보다 더 큰 프로세스를 실행할 수 있게 하는 기술
-   가상 메모리 기법에는 크게 `페이징`과 `세그멘테이션`이 있다. 현대 운영체제가 사용하는 기법은 대부분 `페이징 기법`이다.

<br/>

## 페이징 기법

**외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다.**

만약, 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 외부 단편화는 발생하지 않을 것이다. 이런 기법을 `페이징`이라고 한다.<br/>
페이징은 프로세스의 논리 주소 공간을 `페이지`라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 `프레임`이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

**페이징은 메모리의 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 방식이다.**

페이징에서 스와핑을 사용할 수 있다. 프로세스 전체가 스왑 아웃 및 스왑 인이 되는 것이 아닌 페이지 단위로 스왑 아웃 및 스왑 인이 가능하다.<br/>
다시 말해, 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃되고, 실행에 필요한 페이지들은 메모리로 스왑 인이 되는 것이다. (페이지 아웃 및 페이지 인)

<br/>

## 페이지 테이블

프로세스가 메모리에 불연속적으로 배치되어 있으면 CPU 입장에서 순차적으로 실행할 수 없다. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기 어렵기 때문이다.<br/>
**즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 다음에 실행할 명령어 위치를 찾기가 어려워진다.**

이러한 문제점을 해결하기 위해 페이징 시스템은 **프로세스가 비록 실제 메모리 내의 주소인 물리 주소에 불연속적으로 배치되더라도 CPU가 바라보는 주소인 논리주소에는 연속적으로 배치되도록** `페이지 테이블`을 생성한다.

**페이지 테이블은 페이지 번호와 프레임 번호를 짝지어주는 이정표**이다. CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다.

프로세스마다 각자의 프로세스 테이블을 가지고 있고, 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다. 그리고 `CPU 내의 페이지 테이블 베이스 레지스터(PTBR)`는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.<br/>
**참고로, 각 프로세스들의 페이지 테이블 정보는 각 프로세스의 PCB에 기록하고 있다. 그리고 Context-Switching이 일어날 때 다른 레지스터와 마찬가지로 함께 변경된다.**

### 내부 단편화

페이징은 외부 단편화를 해결할 수 있지만 `내부 단편화` 라는 문제를 야기할 수 있다. 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자른다고 했는데, 모든 프로세스가 페이지 크기에 맞춰 딱 잘려지는 건 아닐 것이다. 페이지 크기가 10KB인데 프로세스의 크기가 108KB라고 한다면 마지막 페이지는 2KB 만큼의 크기가 남는다.<br/>
이러한 메모리 낭비를 `내부 단편화` 라고 한다.

내부 단편화는 하나의 크기보다 작은 크기로 인해 발생하는데, 하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 수 있다.<br/>
그렇지만, 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비된다.

그래서 적당히 페이지 크기를 선정해야 하는 것이다.

### TLB (Translation Lookaside Buffer)

페이지 테이블을 메모리에 두면 문제가 발생할 수 있다. 메모리 접근 시간이 2배로 늘어난다는 점이다.<br/>
메모리에 있는 페이지 테이블을 보기 위해서 1번, 그렇게 알게 된 프레임에 접근하기 위해 한번으로 총 2번의 메모리 접근이 필요하다.

이와 같은 문제를 해결하기 위해 CPU 곁에 일반적으로 `TLB라는 페이지 테이블의 캐시 메모리`를 둔다.<br/>
TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다.

<br/>

## 페이징에서의 주소 변환

페이지 테이블에 페이지 번호와 프레임 번호 외에도 `유효 비트, 보호 비트, 참조 비트, 수정 비트`가 있다.

### 유효 비트(Valid Bit)

-   현재 해당 페이지에 접근 가능한지 여부를 알려준다.
-   일반적으로 프로세스를 이루는 모든 페이지가 메모리에 있지 않다. 일부 페이지는 보조기억장치에 있는 경우가 많다.
-   **유효 비트는 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 적재되어 있는지를 알려주는 비트이다.**

만약 CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하면 **페이지 폴트(Page Fault)가 발생한다.**

#### CPU가 페이지 폴트를 처리하는 과정

> 하드웨어 인터럽트 처리 과정과 유사하다.

-   CPU는 기존의 작업 내역을 백업한다.
-   페이지 폴트 처리 루틴을 실행한다.
-   페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경한다.
-   페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근할 수 있게 된다.

### 보호 비트(Protection Bit)

-   페이지 보호 기능을 위해 존재하는 비트
-   읽고 쓰기가 모두 가능한 페이지인지, 읽기만 가능한 페이지인지를 나타낼 수 있음.
-   우리가 아는 리눅스의 rwx가 해당 내용이다.

### 참조 비트(Reference Bit)

-   CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄

### 수정 비트(Modified Bit)

-   페이지에 데이터를 쓴적이 있는지 없는지에 대한 여부
-   `더티 비트(Dirty Bit)` 라고도 부른다.

#### 수정 비트가 존재하는 이유

수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야하는지 할 필요가 없는지를 판단하기 위해 존재한다.

CPU는 메모리를 읽기도 하지만 쓰기도 한다. CPU가 한 번도 접근하지 않았거나 읽기만 한 페이지의 경우 보조기억장치에 저장된 해당 페이지의 내용과 메모리에 저장된 페이지 내용이 같다.
이렇게 한 번도 수정된 적이 없는 페이지가 스왑 아웃될 경우 아무런 추가 작업 없이 새로 적재된 페이지로 덮어쓰기만 하면 된다.

**하지만 CPU가 쓰기 작업을 수행한 페이지(수정 비트가 1인 페이지)인 경우 보조기억장치에 저장된 페이지의 내용과 메모리에 저장된 페이지의 내용이 서로 다르다.
수정된 적이 있는 페이지가 스왑 아웃이 될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가되어야 한다.**

이러한 작업이 필요한 페이지인지 아닌지를 판단하기 위해 페이지 테이블 엔트리에 수정 비트를 두는 것이다.
