# 혼공컴운 챕터4) CPU의 작동 원리

> `읽은 범위`: **p.103 ~ p.125**

## 4-1) ALU와 제어장치

### ALU

-   ALU는 계산하는 부품 (계산기)
-   `1+2` 라는 계산을 하기 위해서는 1과 2라는 피연산자 2개와 더하기라는 수행할 연산이 필요하다.
-   **ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다.**
-   ALU가 연산을 수행한 결과는 바로 메모리에 저장되지 않고 **일단 레지스터에 저장**됩니다.
    -   **CPU가 레지스터에 접근하는 시간이 메모리에 접근하는 시간보다 훨씬 빠르기 때문이다.**
-   부가적으로, 덧셈을 위한 가산기, 뺄셈을 위한 보수기, 시프트 연산을 수행해주는 시프터, 오버플로우 검출기 등이 있다.

#### Flag

> -   **연산 결과에 대한 추가적인 상태정보**
> -   CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 참고 정보
> -   플래그 레지스터라는 레지스터에 저장된다

-   ALU가 결과값을 내보낼 때 붙을 추가적인 정보
-   결과가 음수, 연산결과를 담을 레지스터보다 클 때(Overflow) 등
-   **부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그** 등이 있다.
    -   `인터럽트 플래그`: 인터럽드 가능 여부 따짐
    -   `슈퍼바이저 플래그`: 커널모드 OR 사용자 모드 확인

### 제어 장치

> -   제어장치: **제어신호를 내보내고 명령어를 해석하는 부품**
> -   제어신호: **컴퓨터 부품들을 관리하고 작동시키기 위한 전기신호**

#### (1) 제어장치는 클럭 신호를 받아들인다.

-   `클럭(clock)`: 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간단위
-   `컴퓨터의 모든 부품이 클럭 신호에 맞춰 작동한다` != `컴퓨터의 모든 부품이 한 클럭마다 작동한다`

#### (2) 제어장치는 `해석해야 할 명령어`를 받아들인다.

-   CPU가 해석해야 할 명령어는 `명령어 레지스터`라는 레지스터에 저장된다.
-   해당 레지스터로부터 명령어를 받아들이고 해석한 뒤에 제어신호를 발생시킨다.

#### (3) 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다.

-   제어장치가 제어신호를 통해 컴퓨터 부품들을 제어할 때 Flag라는 참고 사항을 무시하면 안될 것이다.

#### (4) 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들인다.

-   제어신호는 CPU 뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다.
-   **제어버스를 통해 외부로부터 전달된 제어신호를 받아들이기도 한다.**

제어장치가 내보내는 정보는 `CPU 외부에 전달하는 제어신호`와 `CPU 내부에 전달하는 제어신호`가 있다.<br/>
제어장치가 CPU 외부에 제어신호를 전달한다는 것은 제어버스로 제어신호를 내보낸다는 의미이다.<br/>
여기서 제어신호는 메모리에 전달하는 제어신호와 입출력장치에 전달하는 제어신호가 있다.

<br/>

CPU 내부에 전달하는 제어신호는 `ALU에 전달하는 제어신호`와 `레지스터에 전달하는 제어 신호`가 있다.<br/>
ALU에는 수행할 연산을 지시하기 위해, 레지스터는 레지스터 간의 데이터를 이동시키거나 저장된 명령어를 해석하기 위해.

### 정리

-   `ALU`: 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어신호를 받아들임.
-   ALU는 연산결과와 `플래그`를 내보내고 이는 플래그 레지스터에 저장된다.
-   `제어장치`는 클럭, 현재 수행할 명령어, Flag, 제어 신호를 받아들인다.
-   제어장치는 CPU 내부와 외부로 제어신호를 보낸다.

<br/>

## 4-2) 레지스터

> -   프로그램 카운터
> -   명령어 레지스터
> -   메모리 주소 레지스터
> -   메모리 버퍼 레지스터
> -   플래그 레지스터
> -   범용 레지스터
> -   스택 포인터
> -   베이스 레지스터

### 프로그램 카운터 (PC: Program Counter)

-   메모리에서 가져올 명령어의 주소
-   메모리에서 읽어 들일 명령어의 주소를 저장함
-   `명령어 포인터(IP: Instruction Pointer)` 라고 부르는 CPU도 있다.

### 명령어 레지스터 (IR: Instruction Register)

-   메모리에서 읽어들인 명령어를 저장하는 레지스터
-   제어장치는 명령어 레지스터 속 명령어를 받아들이고 해석한 뒤에 제어신호를 내보낸다.

### 메모리 주소 레지스터 (MAR: Memory Address Register)

-   메모리의 주소를 저장하는 레지스터
-   CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

### 메모리 버퍼 레지스터 (MBR: Memory Buffer Register / MDR: Memory Data Register)

-   메모리와 주고받을 값인 데이터와 명령어를 저장하는 레지스터
-   메모리에 쓰고 싶은 값이나 메모리부터 전달받은 값은 메모리 버퍼 레지스터를 거친다.
-   CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다.

### 범용 레지스터 (General Purpose Register)

-   다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
-   MBR은 데이터 버스로 주고받을 값만 저장함, MAR은 주소 버스로 내보낼 주소값만 저장
-   범용 레지스터는 이 둘을 모두 저장할 수 있음.

### 플래그 레지스터 (Flag Register)

-   연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

### 특정 레지스터를 이용한 주소 지정 방식 -> **스택 주소 지정 방식과 변위 주소 지정 방식**

#### 스택 주소 지정 방식

> -   스택 포인터 (Stack Pointer): 스택 주소 지정 방식이라는 주소 지정 방식에 사용됨
> -   스택 주소 지정 방식: 스택과 스택 포인터를 이용한 주소 지정 방식
> -   스택의 꼭대기를 가리키는 레지스터 -> 스택 포인터!

#### 변위 주소 지정 방식 (displacement addressing mode)

> -   명령어 = 연산코드 + 오퍼랜드
> -   **오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더해서 유효주소를 얻어내는 주소 지정 방식**
> -   따라서, 변위 주소 지정 방식을 사용하는 명령어는 연산코드필드, 어떤 레지스터의 값과 더할지를 명시하는 레지스터 필드 그리고 주소를 담고 있는 오퍼랜드 필드가 있다.
> -   상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식으로 나뉜다.

##### (1) 상대 주소 지정 방식 (relative addressing mode)

> -   오퍼랜드와 프로그램 카운터(PC)의 값을 더해서 유효 주소를 얻어내는 방식
> -   PC에 저장되어 있는 값: 메모리에서 읽어 들일 명령어의 주소
> -   **특정 주소의 코드를 실행할 때 사용된다.**

##### (2) 베이스 레지스터 주소 지정 방식 (base-register addressing mode)

> -   오퍼랜드와 베이스 레지스터 값을 더해서 유효 주소를 얻는 방식
> -   베이스 레지스터는 기준 주소, 오퍼랜드는 기준 주소로부터 떨어진 거리
