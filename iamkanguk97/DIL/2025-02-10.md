# 챕터11) CPU 스케줄링

## 프로세스의 우선순위

프로세스 마다 우선순위가 다르다. 당연하게도 우선순위가 높은 프로세스는 빠르게 처리를 해야한다.
**우선순위가 높은 프로세스에는 대표적으로 입출력 작업이 많은 프로세스가 있다.**

**예를 들어, `워드 프로세서`는 CPU를 사용해서 명령어를 실행하고, 사용자로부터 입력받은 내용을 보조기억장치에 저장하고, CPU를 사용해서 명령어를 실행하고, 사용자가 입력한 내용을 모니터에 출력하는 과정을 반복해서 실행한다.**

### 입출력 집중 프로세스 vs CPU 집중 프로세스

-   `입출력 집중 프로세스`: 비디오 재생 또는 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스
-   `CPU 집중 프로세스`: 복잡한 수학 연산, 컴파일, 그래픽 처리 작업과 같이 프로세스와 같이 CPU 작업이 많은 프로세스

보통 입출력 집중 프로세스는 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무른다. 반대로 CPU 집중 프로세스는 대기 상태보다는 실행 상태에 더 많이 머무른다.

### CPU 버스트와 입출력 버스트

-   `CPU 버스트`: CPU를 이용하는 작업
-   `입출력 버스트`: 입출력장치를 기다리는 작업

**그래서 운영체제는 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해서 운영체제는 프로세스마다 우선순위(priority)를 부여한다.**

각 프로세스의 PCB에 우선순위를 명시하고, PCB에 기록된 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

<br/>

## 스케줄링 큐

PCB에 우선순위가 적혀있지만 CPU를 사용할 다음 프로세스를 찾기위해 운영체제가 일일이 PCB를 뒤지는 것은 비효율적이다.

그래서 운영체제는 프로세스들이 `줄을 서서 기다릴 것`을 요구한다. CPU를 사용하고 싶은 프로세스, 메모리에 적재되고 싶은 프로세스, 특정 입출력장치를 사용하고 싶은 프로세스를 모두 줄세운다. 이를 **스케줄링 큐(Scheduling Queue)로 구현하고 관리한다.**

### 준비 큐와 대기 큐

-   `준비 큐(ready queue)`: CPU를 이용하고 싶은 프로세스들이 서는 줄
-   `대기 큐(waiting queue)`: 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

<br/>

## 선점형과 비선점형 스케줄링

> -   `선점형 스케줄링`: 지금 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당하는 방식
> -   `비선점형 스케줄링`: CPU를 사용하고 있는 프로세스의 작업이 끝날 때까지 다른 급한 프로세스를 기다리게 하는 방식

### 선점형 스케줄링

> 선점: 나보다 앞서서 차지함

-   프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
-   **현재 대부분의 운영체제는 선점형 스케줄링 방식을 사용하고 있다.**
-   더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이기 때문에 어느 한 프로세스의 자원 독점을 막고 프로세스들에게 골고루 자원을 배분할 수 있다는 장점이 있다.
-   다만, 그만큼 Context-Switching 과정에서 Overhead가 발생할 수 있음.

### 비선점형 스케줄링

-   하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식
-   Context-Switching 횟수가 선점형 스케줄링보다 적기 때문에 context-switching에서 발생하는 Overhead는 선점형 스케줄링보다 적음.
-   다만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수 밖에 없다.

<br/>

## 11-2) CPU 스케줄링 알고리즘

## 스케줄링 알고리즘의 종류

### 선입 선처리 스케줄링 (FCFS - First Come First Served Scheduling)

> **준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식**

-   즉, CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식.
-   공정해 보이지만, 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용이 있음.
-   `호위 효과(convoy effect)`: 시간을 기다리는 것

### 최단 작업 우선 스케줄링 (SJF - Shortest Job First Scheduling)

> **준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식**

SJF 스케줄링은 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로도 구현될 수 있다 (선점형 최단 작업 우선 스케줄링)

### 라운드 로빈 스케줄링 (RR - Round Robin Scheduling)

> -   `선입 선처리 스케줄링(FCFS)` + `타임 슬라이스`
> -   `타임 슬라이스`: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
> -   **즉, 라운드 로빈 스케줄링은 정해진 타임 슬라이스만큼의 시간동안 돌아가면서 CPU를 이용하는 선점형 스케줄링**

준비 큐에 삽입된 프로세스들은 삽입된 순서대로 CPU를 이용하되 정해진 시간만큼만 CPU를 이용하고 정해진 시간을 모두 사용하였음에도 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입되는데 이 때 `Context-Switching`이 발생한다.

타임 슬라이스 크기가 매우 중요하다. 지나치게 크면 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 타임 슬라이스 크기가 지나치게 작으면 Context-Switching에 발생하는 비용이 커서 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는데 힘을 다 쓸 여지가 있음.

### 최소 잔여 시간 우선 스케줄링 (SRT - Shortest Remaining Time Scheduling)

> -   최단작업우선스케줄링(SJF) + 라운드로빈스케줄링(RR)
> -   작업시간이 짧은 프로세스부터 처리 + 정해진 타임 슬라이스만큼 돌아가면서 CPU 사용

**최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.**

### 우선순위 스케줄링 (Priority Scheduling)

> -   프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행
> -   우선순위가 같은 프로세스들은 선입 선처리로 스케줄링된다.

최단작업우선 스케줄링(SJF), 최소잔여시간우선 스케줄링(SRT)은 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있다.

SJF는 작업 시간이 짧은 프로세스에 높은 우선순위를 부여하는 것이고, SRT는 남은 시간이 짧은 프로세스에 높은 우선순위를 부여하는 방식이기 때문이다.

**우선순위 알고리즘은 근본적인 문제가 있다. 우선순위가 높은 프로세스를 우선적으로 처리하기 때문에 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스들에 의해 실행이 계속해서 연기될 수 있는 것이다.** (기아 현상 - starvation)

이를 방지하기 위해 `에이징 기법`이 있다. **오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다.**

대기중인 프로세스의 우선순위를 나이 먹듯 점차 증가시키는 방법이다. 그러면 우선순위가 낮아서 마냥 기다리는 프로세스가 없어진다.

### 다단계 큐 스케줄링 (Multilevel queue scheduling)

> -   우선순위 스케줄링의 발전된 형태
> -   우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
> -   우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리한다.

**큐를 여러개 두면 프로세스 유형별로 우선순위를 구분해서 실행하는 것이 편리해진다. 큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있다.**

### 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)

> -   다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없음
> -   그러면, 우선순위가 낮은 프로세스들은 계속 연기될 여지가 있음 -> 기아 현상

다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 먼저 삽입되고, 일정 시간동안 실행된다.

그리고 만약 프로세스가 해당 큐에서 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행된다. 지속되다보면 결국에 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아진다.

다시 말해서, CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스럽게 우선순위가 높아지는 것이다.

낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용해서 기아 현상을 예방할 수 있음.

> **다단계 피드백 큐 스케줄링 알고리즘은 어떤 프로세스의 CPU 이용시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘임.**

그리고 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져있음.
