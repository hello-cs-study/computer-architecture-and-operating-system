# 챕터5) CPU 성능 향상 기법

## 5-1) 빠른 CPU를 위한 설계 기법

## 클럭

-   클럭 신호가 빠르게 반복되면 CPU를 비롯한 컴퓨터 부품들은 그만큼 빠른 박자에 맞춰서 움직임 -> 컴퓨터 부품들은 클럭 신호에 맞춰서 일사불란하게 움직이기 때문이다.
-   실제로 클럭속도가 높은 CPU는 일반적으로 성능이 좋다 -> 클럭 속도는 CPU 속도 단위로 간주

### 클럭 속도

-   헤르츠(Hz) 단위로 측정 (1초에 클럭이 몇 번 반복되는지를 나타냄)
    -   클럭이 똑딱 하고 1초에 한번 반복되면 1Hz, 똑딱하고 1초에 100번 반복되면 100Hz
-   예를 들어, 2.5GHz라고 한다면 1초에 클럭이 25억번 반복된다는 것이다 (2.5 \* 10^9)
-   그렇지만 클럭 속도를 엄청 높인다고 해서 CPU가 빠르지는 않음. 클럭 속도를 무작정 높이게 되면 발열 문제가 심각해진다.

### 클럭 속도는 일정하지 않음

-   고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고 그렇지 않을 때는 유연하게 클럭 속도를 낮춘다.
-   최대 클럭 속도를 강제로 더 끌어올릴 수 있는데 이는 `오버클럭킹(Overclocking)` 이라고 한다.

## 코어와 멀티코어

> **컴퓨터를 구매할 때 8코어 CPU라고 많이들 부른다.**

-   CPU는 명령어를 실행하는 부품이라고 정의했었는데 이는 `코어`를 의미한다.
-   다시 말해서, 오늘날의 CPU는 단순히 명령어를 실행하는 부품에서 `명령어를 실행하는 부품을 여러 개 포함하는 부품` 으로 명칭의 범위가 확장되었음.
-   코어를 여러개 포함하고 있는 CPU를 `멀티코어 CPU` 또는 `멀티코어 프로세서`라고 부른다.
-   그런데 코어 수를 늘린다고 연산속도가 비례해서 증가하지는 않음.

## 스레드와 멀티스레드

-   `스레드(Thread)`: 실행 흐름의 단위 (참고로 CPU에서의 스레드와 프로그래밍에서 사용되는 스레드는 다르다)
-   즉, 스레드에는 CPU에서 사용되는 `하드웨어적 스레드`가 있고 프로그램에서 사용되는 `소프트웨어적 스레드`가 있다.

### 하드웨어적 스레드

-   `하나의 코어가 동시에 처리하는 명령어 단위`
-   e.g) 2코어 4스레드 -> 명령어를 실행하는 부품을 2개 포함하고 한 번에 4개의 명령어를 처리할 수 있는 CPU
-   하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 `멀티스레드 프로세서` 또는 `멀티스레드 CPU` 라고 칭한다.

#### 참고) 하이퍼스레딩 (Hyper-Threading)

> 인텔의 멀티스레드 기술을 의미한다.

### 소프트웨어적 스레드

-   `하나의 프로그램에서 독립적으로 실행되는 단위`
-   예를 들어, 워드 프로세서 프로그램을 개발한다고 가정해보자.
    -   사용자로부터 입력받은 내용을 화면에 보여줘야함
    -   입력한 내용이 맞춤법이 맞는지 검사해야함
    -   입력한 내용을 수시로 저장해야함
-   위 3개의 기능을 각 스레드로 만들면 동시에 실행할 수 있다.

### 정리

-   `하드웨어적 스레드`: 하나의 코어가 동시에 처리하는 명령어 단위
-   `소프트웨어적 스레드`: 하나의 프로그램에서 독립적으로 실행되는 단위
-   **즉, 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십개 실행할 수 있다.**

### 멀티스레드 프로세서

> **하나의 코어로 여러 명령어를 동시에 처리하는 CPU**

### 멀티코어와 멀티스레드의 차이

-   코어: 명령어를 실행할 수 있는 하드웨어 부품
-   스레드: 명령어를 실행하는 단위
-   멀티코어 프로세서: 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 2개 이상 있는 CPU
-   멀티스레드 프로세서: 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

<br/>

## 5-2) 명령어 병렬 처리 기법

> -   명령어를 동시에 처리해서 CPU를 한시도 쉬지 않고 작동시키는 기법 -> 명령어 병렬처리 기법 (ILP: Instruction Level Parallelism)
> -   크게 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리가 있다.

### 명령어 파이프라이닝

-   명령어 인출, 명령어 해석, 명령어 실행, 결과 저장
-   하나의 시간에 여러 명령어를 실행할 수 있는데 같은 명령어는 되지 않음.
-   파이프라이닝이 높은 성능을 가져오기도 하지만 특정 상황에서는 성능 향상에 실패하는 경우도 있다 -> 파이프라이닝 위험 (Pipeline Hazard)
    -   데이터 위험, 제어 위험, 구조적 위험

#### 데이터 위험 (Data Hazard)

> -   명령어 간 `데이터 의존성`에 의해 발생
> -   어떤 명령어는 이전 명령어를 다 실행하고 나서 실행할 수 있는 경우가 있다.

예를 들어, 다음과 같은 2개의 명령어가 있다고 하자.

-   I1: R1 <- R2 + R3
-   I2: R4 <- R1 + R5

R1은 I1 명령어가 다 끝나고 나서 I2에서 사용할 수 있다. 즉 의존성이 성립되고 있는 것이다.
이를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 동작하지 않을 수 있다.

#### 제어 위험 (Control Hazard)

-   `분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생`
-   프로그램 카운터는 현재 실행중인 명령어의 다음 주소로 갱신된다.
-   만약, 프로그램 실행 흐름이 바뀌어서 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 파이프라인에서 미리 가지고와서 처리중이었던 명령어들은 쓸모가 없어진다.
-   `분기 예측(branch prediction)`: 프로그램이 어디로 분기할 지 미리 예측한 후 그 주소를 인출하는 기술

#### 구조적 위험 (Structural Hazard)

-   명령어들을 겹쳐서 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생된다.
-   구조적 위험은 자원 위험이라고도 부른다.

### 슈퍼스칼라 (Superscalar)

<br/>

## 5-3) CISC와 RISC

> -   CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면? -> CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝하기 쉽게 생겨야한다.
> -   파이프라이닝하기 쉽게 생긴 언어? -> ISA를 기반으로 설계된 CISC와 RISC

## 명령어 집합

-   CPU를 제조하는 회사는 굉장히 많다. 그리고 각 회사마다 규격과 기능 등이 다르다.
-   이처럼 각 CPU마다 차이가 있을 수 있는데 CPU가 이해할 수 있는 명령어들의 모음을 `ISA(Instruction Set Architecture)` 라고 부른다.
-   다시 말해서, CPU 마다 ISA가 다를 수 있다는 점이다.
-   예를 들어, 인텔의 노트북 속 CPU는 x86 혹은 x86-64 ISA를 이해하고, 애플의 아이폰 속 CPU는 ARM ISA를 이해한다.

## CISC (Complex Instruction Set Computer)

> -   복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
> -   x86, x86-64가 대표적인 CISC 기반의 ISA이다.

-   `가변 길이 명령어`를 활용하고 있음.
