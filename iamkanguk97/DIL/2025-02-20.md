# 가상 메모리

## 스와핑

메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 있을 수 있다.
(입출력 작업 오구로 인한 대기, 오랫동안 사용되지 않은 프로세스 등)

**이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재해서 실행하는 방식을 `스와핑(Swapping)` 이라고 한다.**

-   `스왑 영역`: 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
-   `스왑 아웃`: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
-   `스왑 인`: 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

**스와핑의 장점으로는 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다는 점이다.** (swap-memory)

## 메모리 할당과 외부 단편화

메모리 할당은 최초 적합, 최적 적합, 최악 적합 방식이 있음. (설명은 생략)

프로세스를 메모리에 연속적으로 배치하는 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법이 아니다. 왜냐하면 연속 메모리 할당은 `외부 단편화` 라는 문제를 내포하고 있기 때문이다.

```
커널영역
------
사용자영역(200MB)
- 프로세스A (50)
- 프로세스B (30)
- 프로세스C (100)
- 프로세스D (20)
```

여기서 B와 D가 실행이 끝나서 빠졌다고 가정해보자.

```
커널영역
------
사용자영역(200MB)
- 프로세스A (50)
- (공백) (30)
- 프로세스C (100)
- (공백) (20)
```

이 상황에서 50MB 크기의 프로세스를 적재할 수 있을까? 적재하지 못한다.
프로세스들이 메모리에 연속적으로 할당되는 환경에서는 위와 같이 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다.

프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어지는데 이러한 상황을 `외부 단편화` 라고 한다.

### 외부 단편화를 해결할 수 있는 방법: 압축

> 메모리 조각 모음이라고도 부른다.

-   메모리 내에 저장된 프로세스를 적당히 재배치시켜서 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법이다.
-   다만 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 한다는 단점이 있으며, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하고, 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어렵다.
-   이런 외부 단편화를 없앨 수 있는 방안이 등장했는데 그것이 `가상 메모리 기법 -> 페이징 기법` 이다.

<br/>
